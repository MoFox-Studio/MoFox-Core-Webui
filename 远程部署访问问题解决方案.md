# 远程部署访问问题解决方案

## 问题描述

GitHub Issue: https://github.com/MoFox-Studio/MoFox-Core-Webui/issues/2

用户通过 Docker 部署 Bot 后加入 WebUI 插件，尝试远程访问时遇到以下问题：
1. 使用公网 IP 访问时显示 "Failed to fetch"
2. 使用反向代理访问时显示 "连接服务器失败，请确保Bot已启动且插件正常运行"
3. 插件已成功加载，没有错误日志

## 问题分析

### 架构说明

当前 WebUI 采用双服务器架构：
1. **发现服务器（Discovery Server）**
   - 固定端口：12138
   - 作用：提供主程序的 IP 和端口信息
   - 托管前端静态文件

2. **主程序服务器（Main Server）**
   - 动态端口（可配置）
   - 提供实际的 API 服务

### 问题根源

通过分析代码发现问题在于前端的连接逻辑：

**文件：`forward/mofox-webui/src/api/index.ts`**
```typescript
// 发现服务器配置（固定端口，用于获取主程序信息）
const DISCOVERY_SERVER_PORT = 12138
const DISCOVERY_SERVER_URL = `http://${window.location.hostname}:${DISCOVERY_SERVER_PORT}`

// ...

export async function getApiBaseUrl(): Promise<string> {
  const serverInfo = await getServerInfo()
  return `http://${serverInfo.host}:${serverInfo.port}`
}
```

**关键问题：**

1. **Discovery Server URL 构建问题**
   - 使用 `window.location.hostname` 构建发现服务器地址
   - 在本地访问时（如 localhost:12138）这没问题
   - 但在远程访问/Docker/反向代理场景下会出现问题

2. **API Base URL 构建问题**
   - 从 Discovery Server 获取到的 `host` 和 `port` 直接用于构建 API URL
   - 在 Docker 部署时，返回的 `host` 可能是内网地址（如 127.0.0.1）
   - 远程客户端无法访问内网地址

3. **协议问题**
   - 硬编码使用 `http://` 协议
   - 如果反向代理使用 HTTPS，会导致混合内容（Mixed Content）错误

**文件：`backend/discovery_server.py`**
```python
def create_discovery_app(main_host: str, main_port: int) -> FastAPI:
    # ...
    @app.get("/api/server-info", summary="获取主程序服务器信息", response_model=ServerInfo)
    def get_server_info():
        return ServerInfo(
            host=main_host,
            port=main_port
        )
```

问题：
- Discovery Server 默认绑定到 `127.0.0.1`（见 `start_discovery_server` 函数）
- 在 Docker 容器中，这会导致从容器外部无法访问
- 返回的 `main_host` 如果是 `127.0.0.1`，远程无法访问

### 🏆 最佳解决方案

**强烈推荐使用方案 0（发现服务器代理模式）：**

✅ **优点：**
- 改动最小，实现最简单
- 完美适配所有部署场景
- 用户只需要知道一个端口（12138）
- 无跨域问题，天然支持 HTTPS
- Docker 只需暴露一个端口

❌ **缺点：**
- 发现服务器成为单点（但本来就是必需的）
- 增加一次请求转发（延迟可忽略不计）

### 方案对比

| 方案 | 复杂度 | 适用场景 | 推荐度 |
|-----|-------|---------|--------|
| **方案 0：代理模式** | ⭐ 极简 | 所有场景 | ⭐⭐⭐⭐⭐ |
| 方案 1：智能构建 | ⭐⭐ 中等 | 需要灵活配置 | ⭐⭐⭐ |
| 方案 2：反向代理 | ⭐⭐⭐ 复杂 | 大型生产环境 | ⭐⭐⭐⭐ |
| 方案 3：直接暴露 | ⭐⭐ 中等 | 不推荐 | ⭐ |

### 部署建议

1. **开发环境**：方案 0，开箱即用
2. **小型部署**：方案 0，简单可靠
3. **生产环境**：方案 0 + Nginx HTTPS，兼顾简单和安全
4. **大型集群**：方案 2，使用专业反向代理和负载均衡

### Q1: 为什么使用双服务器架构？

**A:** 为了灵活性和解耦：
- Discovery Server 固定端口，方便记忆和配置
- 主程序端口可以动态配置，避免端口冲突
- 便于负载均衡和服务发现

### Q2: 反向代理是必须的吗？

**A:** 不是必须的，但强烈推荐：
- 统一入口，避免暴露多个端口
- 可以添加 HTTPS 支持
- 可以添加认证、限流等安全措施
- 避免跨域问题

### Q3: Docker 部署有什么特殊注意事项？

**A:** 主要注意点：
- 端口映射要完整（12138 和主程序端口）
- 绑定地址使用 `0.0.0.0` 而非 `127.0.0.1`
- 网络模式选择 `bridge` 或 `host`
- 考虑使用 docker-compose 简化配置

## 总结

该问题的核心在于**网络地址的正确处理**：

1. **开发环境**：使用发现服务器自动获取配置
2. **生产环境**：推荐使用反向代理 + 相对路径
3. **Docker 环境**：确保绑定地址和端口映射正确

建议采用**方案 1 + 方案 2** 的组合：
- 前端支持环境变量配置，灵活适应不同场景
- 生产环境使用反向代理，提供最佳用户体验和安全性
- 开发环境使用发现服务器，简化配置

## 参考资料

- [Vue.js 环境变量配置](https://vitejs.dev/guide/env-and-mode.html)
- [Nginx 反向代理配置](https://nginx.org/en/docs/http/ngx_http_proxy_module.html)
- [Docker 网络配置](https://docs.docker.com/network/)
- [FastAPI CORS 配置](https://fastapi.tiangolo.com/tutorial/cors/)
